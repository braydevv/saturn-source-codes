<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta charset="utf-8"/>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <title>Brawl Stars (Fixed)</title>
  <style>
    html, body {
      width: 100%;
      height: 100%;
      padding: 0px;
      margin: 0px;
    }
    .fullscreen {
      background: #242424;
      width: 100%;
      height: 100%;
      position: absolute;
      top: 0px;
      left: 0px;
    }
    #banner-container {
      position: absolute;
      bottom: 0px;
      width: 100%;
      height: 90px;
    }
    #loading-overlay {
      font-size: 20px;
      z-index: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
    }
    #icon {
      max-width: 300px;
      border-radius: 10px;
      margin-bottom: 20px;
    }
    #progress-bar {
      border-radius: 5px;
      width: 90%;
      max-width: 250px;
      height: 20px;
      background: #181818;
      padding: 5px;
    }
    #progress-bar-fill {
      border-radius: 3px;
      width: 0%;
      height: 100%;
      background: #9747FF;
    }
  </style>
</head>
<body>
  <canvas id="canvas" class="fullscreen"></canvas>
  <div id="banner-container" style="display: none"></div>
  <div id="loading-overlay" class="fullscreen">
    <img id="icon" src="icon.png"/>
    <div id="progress-bar"><div id="progress-bar-fill"></div></div>
  </div>
  
  <script>
    // Set up viewport for mobile devices
    if (/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)) {
      let meta = document.createElement('meta');
      meta.name = 'viewport';
      meta.content = 'width=device-width, height=device-height, initial-scale=1.0, user-scalable=no, shrink-to-fit=yes';
      document.getElementsByTagName('head')[0].appendChild(meta);
    }

    // Get DOM elements
    let canvas = document.getElementById('canvas');
    let loadingOverlay = document.getElementById('loading-overlay');
    let progressBarFill = document.getElementById('progress-bar-fill');
    let bannerContainer = document.getElementById('banner-container');

    // Constants for storage
    const STORAGE_DATA_SEPARATOR = '{bridge_data_separator}';
    const STORAGE_KEYS_SEPARATOR = '{bridge_keys_separator}';
    const STORAGE_VALUES_SEPARATOR = '{bridge_values_separator}';
    
    // Utils
    window.unityInstance = null;
    let progressBarFillingInterval = null;
    let progressBarCompleteFillingStarted = false;

    function sendMessageToUnity(name, value) {
      if (window.unityInstance !== null) {
        window.unityInstance.SendMessage('PlaygamaBridge', name, value);
      }
    }

    function onUnityLoadingProgressChanged(progress) {
      if (progress >= 1 && progressBarFillingInterval !== null) {
        clearInterval(progressBarFillingInterval);
        progressBarFillingInterval = null;
        return;
      }

      if (progressBarCompleteFillingStarted) {
        return;
      }

      if (progress >= 0.9) {
        progressBarCompleteFillingStarted = true;
        completeProgressBarFilling();
        return;
      }

      progressBarFill.style.width = `${progress * 100}%`;
    }
    
    function completeProgressBarFilling() {
      if (progressBarFillingInterval !== null) {
        return;
      }

      let currentPercent = 90;
      progressBarFill.style.width = `${currentPercent}%`;
      progressBarFillingInterval = setInterval(() => {
        currentPercent++;
        if (currentPercent > 100) {
          currentPercent = 100;
        }

        progressBarFill.style.width = `${currentPercent}%`;

        if (currentPercent >= 100) {
          clearInterval(progressBarFillingInterval);
          progressBarFillingInterval = null;
          return;
        }
      }, 100);
    }

    // Focus handling
    window.addEventListener('pointerdown', () => {
      window.focus();
      canvas.focus();
    });

    // Create a mock bridge object
    const bridge = {
      PLATFORM_ID: {
        GAME_DISTRIBUTION: 'gd',
        YANDEX: 'yandex',
        VK: 'vk',
        OK: 'ok',
        CRAZY_GAMES: 'crazygames',
        ABSOLUTE_GAMES: 'absolutegames',
        GAME_MONSTER: 'gamemonster',
        MOCK: 'mock'
      },
      
      platform: {
        id: 'mock',
        language: 'en',
        payload: '',
        tld: '',
        sendMessage: function(message) {
          console.log('Bridge: sendMessage', message);
        },
        getServerTime: function() {
          return Promise.resolve(Date.now());
        }
      },
      
      device: {
        type: 'desktop'
      },
      
      player: {
        isAuthorizationSupported: true,
        isAuthorized: false,
        id: null,
        name: null,
        photos: [],
        authorize: function(options) {
          console.log('Bridge: authorize', options);
          bridge.player.isAuthorized = true;
          bridge.player.id = 'mock-player-id';
          bridge.player.name = 'Player';
          return Promise.resolve();
        }
      },
      
      game: {
        visibilityState: 'visible',
        on: function(event, callback) {
          console.log('Bridge: game.on', event);
          window.addEventListener('visibilitychange', () => {
            callback(document.hidden ? 'hidden' : 'visible');
          });
        }
      },
      
      storage: {
        defaultType: 'local',
        isSupported: function(storageType) {
          return true;
        },
        isAvailable: function(storageType) {
          return true;
        },
        get: function(keys, storageType, useCache) {
          console.log('Bridge: storage.get', keys, storageType, useCache);
          const data = [];
          for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            const value = localStorage.getItem(key);
            data.push(value ? JSON.parse(value) : null);
          }
          return Promise.resolve(data);
        },
        set: function(keys, values, storageType) {
          console.log('Bridge: storage.set', keys, values, storageType);
          for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            const value = values[i];
            localStorage.setItem(key, JSON.stringify(value));
          }
          return Promise.resolve();
        },
        delete: function(keys, storageType) {
          console.log('Bridge: storage.delete', keys, storageType);
          for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            localStorage.removeItem(key);
          }
          return Promise.resolve();
        }
      },
      
      advertisement: {
        on: function(event, callback) {
          console.log('Bridge: advertisement.on', event);
        },
        showBanner: function(options) {
          console.log('Bridge: showBanner', options);
          return Promise.resolve();
        },
        hideBanner: function() {
          console.log('Bridge: hideBanner');
          return Promise.resolve();
        },
        showInterstitial: function() {
          console.log('Bridge: showInterstitial');
          return Promise.resolve();
        },
        showRewarded: function() {
          console.log('Bridge: showRewarded');
          return Promise.resolve(true);
        }
      },
      
      initialize: function(options) {
        console.log('Bridge: initialize', options);
        return Promise.resolve(bridge);
      }
    };

    // Load the Unity game
    function loadUnityGame() {
      let unityLoader = document.createElement('script');
      unityLoader.src = 'Build/web.loader.js';
      unityLoader.onload = () => {
        createUnityInstance(
          canvas,
          {
            dataUrl: 'Build/web.data.unityweb',
            frameworkUrl: 'Build/web.framework.js.unityweb',
            codeUrl: 'Build/web.wasm.unityweb',
            streamingAssetsUrl: 'StreamingAssets',
            companyName: 'DefaultCompany',
            productName: 'Clicker',
            productVersion: '0.1',
          },
          onUnityLoadingProgressChanged
        )
        .then((unityInstance) => {
          window.unityInstance = unityInstance;
          loadingOverlay.remove();
          canvas.focus();
        })
        .catch((error) => {
          console.error(error);
        });
      };
      document.body.appendChild(unityLoader);
    }

    // Initialize the bridge and load the game
    bridge.initialize({})
      .then(() => {
        // Set up event listeners
        bridge.advertisement.on('banner_state_changed', state => sendMessageToUnity('OnBannerStateChanged', state));
        bridge.advertisement.on('interstitial_state_changed', state => sendMessageToUnity('OnInterstitialStateChanged', state));
        bridge.advertisement.on('rewarded_state_changed', state => sendMessageToUnity('OnRewardedStateChanged', state));
        bridge.game.on('visibility_state_changed', state => sendMessageToUnity('OnVisibilityStateChanged', state));

        // Load the Unity game
        loadUnityGame();
      })
      .catch(error => console.error(error));

    // Platform functions
    window.getPlatformId = function() {
      return bridge.platform.id;
    };

    window.getPlatformLanguage = function() {
      return bridge.platform.language;
    };

    window.getPlatformPayload = function() {
      let payload = bridge.platform.payload;
      if (typeof payload === 'string') {
        return payload;
      } else {
        return '';
      }
    };

    window.getPlatformTld = function() {
      let tld = bridge.platform.tld;
      if (typeof tld === 'string') {
        return tld;
      } else {
        return '';
      }
    };

    window.sendMessageToPlatform = function(message) {
      bridge.platform.sendMessage(message);
    };

    window.getServerTime = function() {
      bridge.platform.getServerTime()
        .then(result => {
          sendMessageToUnity('OnGetServerTimeCompleted', result.toString());
        })
        .catch(error => {
          sendMessageToUnity('OnGetServerTimeCompleted', 'false');
        });
    };

    // Device functions
    window.getDeviceType = function() {
      return bridge.device.type;
    };

    // Player functions
    window.getIsPlayerAuthorizationSupported = function() {
      return bridge.player.isAuthorizationSupported.toString();
    };

    window.getIsPlayerAuthorized = function() {
      return bridge.player.isAuthorized.toString();
    };

    window.getPlayerId = function() {
      if (bridge.player.id) {
        return bridge.player.id.toString();
      }
      return '';
    };

    window.getPlayerName = function() {
      if (bridge.player.name) {
        return bridge.player.name.toString();
      }
      return '';
    };

    window.getPlayerPhotos = function() {
      if (bridge.player.photos.length > 0) {
        return JSON.stringify(bridge.player.photos);
      }
      return '';
    };

    window.authorizePlayer = function(options) {
      if (options) {
        options = JSON.parse(options);
      }

      bridge.player.authorize(options)
        .then(() => {
          sendMessageToUnity('OnAuthorizeCompleted', 'true');
        })
        .catch(error => {
          sendMessageToUnity('OnAuthorizeCompleted', 'false');
        });
    };

    // Game functions
    window.getVisibilityState = function() {
      return bridge.game.visibilityState;
    };

    // Storage functions
    window.getStorageDefaultType = function() {
      return bridge.storage.defaultType;
    };

    window.getIsStorageSupported = function(storageType) {
      return bridge.storage.isSupported(storageType).toString();
    };

    window.getIsStorageAvailable = function(storageType) {
      return bridge.storage.isAvailable(storageType).toString();
    };

    window.getStorageData = function(key, storageType) {
      let keys = key.split(STORAGE_KEYS_SEPARATOR);

      bridge.storage.get(keys, storageType, false)
        .then(data => {
          if (keys.length > 1) {
            let values = [];

            for (let i = 0; i < keys.length; i++) {
              let value = data[i];
              if (value) {
                if (typeof value !== 'string') {
                  value = JSON.stringify(value);
                }

                values.push(value);
              } else {
                values.push('');
              }
            }

            sendMessageToUnity('OnGetStorageDataSuccess', `${key}${STORAGE_DATA_SEPARATOR}${values.join(STORAGE_VALUES_SEPARATOR)}`);
          } else {
            if (data[0]) {
              if (typeof data[0] !== 'string') {
                data = JSON.stringify(data[0]);
              }
            } else {
              data = '';
            }

            sendMessageToUnity('OnGetStorageDataSuccess', `${key}${STORAGE_DATA_SEPARATOR}${data}`);
          }
        })
        .catch(error => {
          sendMessageToUnity('OnGetStorageDataFailed', key);
        });
    };

    window.setStorageData = function(key, value, storageType) {
      let keys = key.split(STORAGE_KEYS_SEPARATOR);
      let values = value.split(STORAGE_VALUES_SEPARATOR);

      bridge.storage.set(keys, values, storageType)
        .then(() => {
          sendMessageToUnity('OnSetStorageDataSuccess', key);
        })
        .catch(error => {
          sendMessageToUnity('OnSetStorageDataFailed', key);
        });
    };

    window.deleteStorageData = function(key, storageType) {
      let keys = key.split(STORAGE_KEYS_SEPARATOR);

      bridge.storage.delete(keys, storageType)
        .then(() => {
          sendMessageToUnity('OnDeleteStorageDataSuccess', key);
        })
        .catch(error => {
          sendMessageToUnity('OnDeleteStorageDataFailed', key);
        });
    };

    // Advertisement functions
    window.showBanner = function(options) {
      if (options) {
        options = JSON.parse(options);
      }

      bridge.advertisement.showBanner(options)
        .then(() => {
          sendMessageToUnity('OnShowBannerCompleted', 'true');
        })
        .catch(error => {
          sendMessageToUnity('OnShowBannerCompleted', 'false');
        });
    };

    window.hideBanner = function() {
      bridge.advertisement.hideBanner()
        .then(() => {
          sendMessageToUnity('OnHideBannerCompleted', 'true');
        })
        .catch(error => {
          sendMessageToUnity('OnHideBannerCompleted', 'false');
        });
    };

    window.showInterstitial = function() {
      bridge.advertisement.showInterstitial()
        .then(() => {
          sendMessageToUnity('OnShowInterstitialCompleted', 'true');
        })
        .catch(error => {
          sendMessageToUnity('OnShowInterstitialCompleted', 'false');
        });
    };

    window.showRewarded = function() {
      bridge.advertisement.showRewarded()
        .then(result => {
          sendMessageToUnity('OnShowRewardedCompleted', result ? 'true' : 'false');
        })
        .catch(error => {
          sendMessageToUnity('OnShowRewardedCompleted', 'false');
        });
    };
  </script>
  
  <!-- Load Howler.js for audio support -->
  <script src="add/howler.js"></script>
</body>
</html>